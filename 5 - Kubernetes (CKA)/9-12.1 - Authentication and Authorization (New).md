# Authentication and Authorization in Kubernetes

Kubernetes me koi bhi user, script, kubectl command, ya API call, agar cluster ke andar koi kaam karna chahta hai — jaise Pod create karna, secret dekhna, ya logs read karna. To ye request API Server par aati hai, to api server is request ko **Authenticate**, **Authorize** aur **Validate (Admission Control)** karta hai.

- **Authentication**: (Tum kaun ho? – Identity verification).
- **Authorization**: (Tumko ye kaam karne ka permission hai ya nahi?).
- **Validation (Admission Control)**: Request allow hone ke baad kya aur checks lagne chahiye?

Jab request api server par aati hai, api server is request ko authenticate, authorize aur validate karta hai, ye hi concept hota hai authentication aur autorization.

<br>

**Flow**
```
[Client] ---> [Kube API Server]
                   |
                   |  Step 1: Authentication
                   |  Step 2: Authorization
                   |  Step 3: Admission Control
                   v
                [Allowed / Denied]
```

<br>
<br>

### 1 - Authentication (Tum kaun ho?)

Authentication ka kaam hai user ki identity verify karna.

Ye check karna ki jo request aa rahi hai woh kis user/service account ne bheji hai aur kya woh asli hai.

Kubernetes mein bhi, jab koi request aati hai (kubectl, API call, dashboard se, ya service-to-service), toh pehle cluster ko ye verify karna padta hai ki ye request kiski hai aur ye banda/service sach mein wahi hai jo bol raha hai.

**Main Point**: Kubernetes apna user store maintain nahi karta jaise ki ek normal web app ka DB hota hai. Iske instead, ye external identity sources pe depend karta hai ya phir certificates, tokens, etc. ke through identity proof le leta hai.

<br>

**Authentication Flow**:
- Client Api Server par request bhejta hai, Client kuch bhi ho sakta hai, jaise:
  - ```kubectl``` command (human user).
  - Another service (service account).
  - External tool (CI/CD pipeline).
  - Kubernetes dashboard UI.
      
- Request ke saath kuch credential hota hai — jaise:
  - Certificate.
  - Token.
  - Username + Password (basic auth).
 
- API Server request ka header dekh ke decide karta hai ki is request ko authenticate karne ke liye kaunsa authenticator use karna hai.
  - Jaise:
    - Static Token File.
    - X.509 Client Certificates.
    - Service Account Tokens (Pods ke liye).
    - OpenID Connect (OIDC).
    - Webhook Token Authentication.
    - Proxy Authentication.
  - API server har incoming request ko sequentially har authenticator se verify karta hai jab tak request authenticate na ho jaye.
 
- Agar authentication pass ho gaya → request **Authorization** step me jaayegi, warna 401 Unauthorized, aur request reject ho jayegi.

<br>

**Types of Kubernetes Authentication**:

<br>

**Static Token File**:
- Tum ek CSV file bana ke API Server ko dete ho jisme har user ka token likha hota hai.

Example:
```
token,user,uid,"group1,group2"
abc123,Puneet,1001,dev-team
```
- API Server start karte waqt flag dete ho.
- Ye method simple hai lekin production me insecure hai kyunki tokens static hai aur manually rotate karne padte hain, testing purpose ke liye thik hai.

<br>

**X.509 Client Certificates**:
- Har user ke paas ek client certificate hota hai jo trusted CA se signed hai.
- Jab tum kubectl se request bhejte ho to TLS handshake ke time API Server tumhara certificate verify karta hai.

Example:
```
kubectl --client-certificate=user.crt --client-key=user.key get pods
```
- Secure aur production me common.

Below is the complete overview.


<br>

**Service Account Tokens (Pods ke liye)**:
- Jab ek Pod ko cluster API access karna hota hai to pod usko service account ke thorugh hota hai to pod ko ek service account assign hota hai.

Example:
- Pod me chal rahi app ko apne namespace ke ConfigMap padhna hai.

- Service account ka token Pod ke andar ```/var/run/secrets/kubernetes.io/serviceaccount/token``` me mount hota hai.
- API Server is token ko verify karta hai.

<br>

**OpenID Connect (OIDC)**:
- Tum external Identity Provider (IDP) use karte ho jaise Google, Azure AD, Okta, etc.
- OIDC me JWT token aata hai jo API Server verify karta hai.
- Ye enterprise me single sign-on (SSO) ke liye best hota hai.

<br>

**Webhook Token Authentication**:
- Tum apna custom auth service likh sakte ho jo API Server se token verify karega.
- API Server webhook ko call karke response leta hai (pass/fail).

<br>

**Proxy Authentication**:
- Tum API Server ke aage ek reverse proxy laga ke auth kara sakte ho (jaise NGINX, Apache).
- Proxy authenticated user ka naam HTTP header me API Server ko pass karta hai.

<br>

**Note**:
- Ek hi API Server me multiple authenticators enable ho sakte hain.
- Har incoming request sequentially har authenticator se verify hoti hai jab tak match na mil jaye.

<br>
<br>
<br>

### 2 - Authorization (Tumko ye kaam karne ka right hai ya nahi?)

Authentication ke baad jab API Server ko pata chal gaya ki tum kaun ho, tab wo check karega ki tum jo kaam kar rahe ho uska permission hai ya nahi.

Authorization ka kaam hota hai permissions check karna.

Authenticated user ya system (jiska identity pehle Authentication step main verify ho chuka hai) kya ye request perform karne ka permission rakhta hai ya nahi?

<br>

**Authorization Flow**:
- API Server tumhari request ke details dekhta hai:
  - User ka naam.
  - User ke groups.
  - Resource (pods, deployments, secrets, etc.).
  - Namespace.
  - Action (get, list, create, delete, patch…).
 
- Authorization module me rules check hota hai.
- Agar match mila to allow, warna forbidden (403).

Authorization main permission check ki jati hai jo request Api Server par aayi hoti hai uski permission check ki jati hai ki is request ko action perform karne ki permission hai ya nhi.

Alag alag type ki request ke liye different roles hote hain.

<br>

**Kubernetes Authorization Modes**:

**1 - Node Authorization**:
- Ye specially kubelets (cluster ke worker nodes) ke liye hota hai.
- Ye authorize karta hai ki kubelet apne node ka data access kar sakta hai ya nahi.

Example:
- Node apne namespace ka Pod list kar sakta hai, lekin dusre node ka nahi.


**2 - ABAC (Attribute-Based Access Control)**:
- Isme Static policy JSON file ke through rules define hote hain.

Example:
```
{
  "apiVersion": "abac.authorization.kubernetes.io/v1",
  "kind": "Policy",
  "spec": {
    "user": "Puneet",
    "namespace": "dev",
    "resource": "pods",
    "readonly": true
  }
}
```
- Flexible hai lekin dynamic nahi — file edit karke API Server restart karna padta hai.
- Modern setup me kam use hota hai.


**3 - RBAC (Role-Based Access Control)**:
- Most common and recommended method.
- Tum roles define karte ho jo ek set of permissions hote hain, fir un roles ko users ya groups bind karte ho.
- Agar koi request Api Server par aayi, uski authentication hogi, fir us request ki authorization hogi, to authorization wale step par check hoga ki kya role assign hai.

<br>

**RBAC Componenets**:

**Role**: Role ek permission hoti hai jo namespace level par define ki jati hai matlab particular namespace par permission provide karti hai.

Example:
```
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: dev
  name: pod-reader
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
```

**ClusterRole**: Cluster Role poore cluster par permission provide karne ke liye role hota hai.

Example:
```
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: cluster-admin
rules:
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["*"]
```

**RoleBinding**: Role Binding ka matlab hai ki role ko kisi user, group, service account ke saath bind karna matlab role ke saath attach karna. Jisse user, service account ko role main jo permission define ki hai vo mil payegi.

Example:
```
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: read-pods
  namespace: dev
subjects:
- kind: User
  name: Puneet
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```

**ClusterRoleBinding**: Cluster binding ka matlab cluster role ko kisi user, group, service account ke saath attach karna. Jisse user, service account ko permission mil payegi.

<br>
<br>
<br>

### Admission Control

Authentication → Authorization ke baad bhi ek extra layer hota hai: Admission Controllers.

Jiska kaam hai: “Request allowed hai, par kya mujhe isse modify ya validate karna chahiye before accept?”

Admission Controllers Kubernetes ke API Server ke andar plugins hote hain jo ek authenticated + authorized request ko modify ya reject kar sakte hain etcd me persist hone se pehle.

Agar request AuthN + AuthZ pass kar leti hai, toh bhi woh directly etcd me save nahi hoti.

Admission Controllers us request ka final check karte hain:
- Validations.
- Default values add karna.
- Security policies enforce karna.
- External systems ko call karke decision lena.

<br>

**Role of Admission Controllers**:

Validation → Wrong configuration ya disallowed settings ko reject karna.
- Example: Ensure pod ke paas invalid imagePullPolicy na ho.

Mutation → Request me defaults add karna ya config modify karna.
- Example: Agar tum namespace specify nahi karte toh default namespace assign karna.

Policy Enforcement → Cluster-wide security aur compliance rules enforce karna.
Example: Only images from private registry allow karna.

<br>

**Admission Control Flow — Step-by-Step**
- Client Request API Server pe aata hai.
- API Server Authentication karta hai (identity verify).
- Authorization hota hai (permissions verify).
- Admission Controller Phase start hota hai:
  - Request ka content inspect hota hai.
  - Admission controller main kaafi plugin hote hain to request har enabled Admission Controller plugin par jati hai aur aagle admission controller par pass ho jati hai.
  - Agar koi plugin reject kare → request fail ho jaati hai (403 Forbidden ya 400 Bad Request).
  - Agar mutate plugin hai → request modify hoti hai.
- Final request etcd me store hoti hai → Cluster state update hota hai.

<br>

**Types of Admission Controllers**:
Admission controllers do main categories me aate hain:

1 - Validating Admission Controllers:
- Sirf allow/deny decision lete hain.
- Request modify nahi karte.

Example:
- ```NamespaceLifecycle``` → Prevent default namespace delete.
- ```PodSecurity``` → Ensure pods comply with Pod Security Standards.

2 - Mutating Admission Controllers:
- Request modify kar sakte hain before save.

Example:
- ```MutatingAdmissionWebhook``` → Add sidecar container automatically.
- ```DefaultNamespace``` → Default namespace assign karna agar specify na ho.

<br>

**Built-in Admission Controllers Examples**:

| Plugin Name                    | Type       | Function                                                        |
| ------------------------------ | ---------- | --------------------------------------------------------------- |
| **NamespaceLifecycle**         | Validating | Prevents operations in non-existent namespaces.                 |
| **LimitRanger**                | Validating | Ensures resource requests/limits are within set constraints.    |
| **ResourceQuota**              | Validating | Ensures resource usage stays within quotas.                     |
| **DefaultStorageClass**        | Mutating   | Assigns default storage class automatically.                    |
| **PodSecurity**                | Validating | Enforces restricted/baseline/privileged pod security standards. |
| **MutatingAdmissionWebhook**   | Mutating   | Allows external service to modify object before creation.       |
| **ValidatingAdmissionWebhook** | Validating | Allows external service to validate object before creation.     |


<br>

Note: Ye hi complete process ko authentication aur authorization bolte hain.

<br>
<br>
<br>

## End-to-End Example Flow

**Scenario**:

Puneet ```kubectl get pods -n dev``` command run karta hai.

**Step 1: Authentication**:
- ```kubectl``` request API Server ko bhejta hai with client certificate.
- API Server certificate verify karta hai → CN = "Puneet", O = "dev-team".

**Step 2: Authorization**:
- API Server dekhta hai ki Puneet ke paas ```RoleBinding``` hai jo ```pod-reader``` Role ko bind karta hai dev namespace me.
- Role allow karta hai ```"get"``` ```"pods"``` resource ke liye.
- Match mil gaya → request allowed.

**Step 3: Admission Control**:
- Koi admission controller is request ko block nahi karta.

Fir Api Server etcd se pod ki list leke response main return karta hai → Puneet ko pods ka list mil jata hai.
