# Custom User in Kubernetes

Jab hum AKS cluster par login karte hain, to hum azure portal par connect option par jake az cli ki command copy karke kubectl main paste karte hain aur aks cluster main login ho jata hai. Ye jo user hota hai ye Admin user ke through login karte hain hum.

Lekin agar ek developer hai usko cluster ke pods dekhne hain bss, to uske liye alag se ek custom user create karke devloper ko access de sakte hain.

<br>

### Background – AKS ka access model

AKS (Azure Kubernetes Service) ek managed Kubernetes cluster hai jo Azure ke control plane par chalta hai.

Kubernetes main access control do cheezon par depend karta hai:
- Authentication – Tum kaun ho? (Identity verification).
- Authorization – Tum kya kar sakte ho? (Permissions verification).

Aur Azure AKS me authentication mostly Azure Active Directory (AAD) ke through hota hai. Matlab tumhare paas ek Azure identity hoti hai (ya to Azure AD user ya Azure AD service principal / managed identity) jo cluster ke against authenticate hoti hai.

<br>

### Jab tum “Connect” button dabate ho Azure Portal me, matlab tum AKS se kubectl ke through kaise connect kar paate ho

**Scenario Example**:
- Maan lo tumhare paas ek AKS cluster hai:
  - Name: ```my-aks-cluster```.
  - Resource group: ```rg-demo```.
  - Azure subscription: ```xxxx-xxxx-xxxx```.
  - Tum Azure Portal me gaye → **Kubernetes services** → **my-aks-cluster** → **Connect** button pe click kiya.
  - Portal ne tumhe ye command di:
  ```
  az aks get-credentials --resource-group rg-demo --name my-aks-cluster
  ```

<br>

**Step 1: Ye command chalate hi kya hota hai**:

Ye uper di hui command ko tum apne local cmd main jaha kubectl install hai wha run karte ho.

**Azure CLI → Azure API**
- ```az aks get-credentials``` ek Azure CLI command hai jo internally Azure Resource Manager (ARM) API call karta hai.
- Ye call tumhare Azure login identity ke saath hota hai:
  - Agar tum Azure CLI me login ho (```az login``` se), to tumhare paas ek AAD access token hota hai.
  - Azure CLI ye token use karke ARM ko call karta hai:

  ```
  GET https://management.azure.com/subscriptions/<sub-id>/resourceGroups/rg-demo/providers/Microsoft.ContainerService/managedClusters/my-aks cluster/listClusterUserCredential?api-version=2023-04-01
  Authorization: Bearer <aad-access-token>
  ```

<br

**step 2: ARM API → AKS Control Plane**:
- Azure Resource Manager tumhara request verify karta hai (tumhare RBAC ke basis par — matlab tumhare Azure role "Azure Kubernetes Service Cluster User" ya "Admin" hona chahiye).
- Agar allowed ho, ARM tumhara request AKS control plane service ko forward karta hai.

<br>

**Step 3: AKS control plane → Kubeconfig generation**:
- AKS ke paas tumhare cluster ka API Server endpoint ka URL aur credentials kaise dene hain uska config hota hai.
- Tumne ```listClusterUserCredential``` ya ```listClusterAdminCredential``` call kiya hai (Azure CLI me --admin option hota hai admin credentials ke liye).
- AKS tumhare liye ek ```temporary kubeconfig``` banata hai:
  - Isme cluster ka server URL hota hai (public or private endpoint).
  - Isme ek Azure AD integration config hota hai ya ek client cert/token hota hai (depend karta hai tumhare AKS ka auth mode).
 
Example config jo Azure return karna hai (AAD enabled mode me):
```
apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: <base64-ca-cert>
    server: https://my-aks-cluster-dns.hcp.eastus.azmk8s.io:443
  name: my-aks-cluster
contexts:
- context:
    cluster: my-aks-cluster
    user: clusterUser_rg-demo_my-aks-cluster
  name: my-aks-cluster
current-context: my-aks-cluster
kind: Config
users:
- name: clusterUser_rg-demo_my-aks-cluster
  user:
    exec:
      apiVersion: client.authentication.k8s.io/v1beta1
      command: az
      args:
        - aks
        - get-credentials
        - --resource-group
        - rg-demo
        - --name
        - my-aks-cluster
        - --token-only
      installHint: Install Azure CLI

```

<br>

**Step 4: Local Machine → Kubeconfig Update**:

Tumhare local system main ek kubeconfig file hoti hai.

Azure CLI ye kubeconfig tumhare local ```~/.kube/config``` file me merge kar deta hai.

Ab tumhare paas ```kubectl``` ke liye cluster ka context ready hai.


<br>

**Step 5: Jab tum kubectl get pods chalate ho**:
- Tumhare kubeconfig me user ke liye ```exec``` block hota hai (Azure CLI call).
- ```kubectl``` jab request bhejne wala hota hai, wo ```exec``` plugin run karta hai — yaha pe ```az aks get-credentials --token-only``` hota hai.
- Azure CLI tumhare Azure login session ka use karke Azure AD token le aata hai (audience: ```6dae42f8-4368-4678-94ff-3960e28e3630``` jo Kubernetes API ke liye hota hai).
- Ye token ek OIDC/JWT access token hota hai jo AKS ke API server pe accept hota hai.

<br>

**Step 6: TLS Handshake + Bearer Token Auth**:
- Jab tum kubectl main koi bhi command likhte ho jaise ```kubectl get pods```, to kubectl API server ke saath TLS handshake karta hai.
- Server apna cert deta hai → client verify karta hai ```certificate-authority-data``` se.
- Yaha client certificate ka use nahi hota (kyunki tum Azure AD mode me ho).

- kubectl API server ko HTTP request bhejta hai:
```
GET /api/v1/namespaces/default/pods
Authorization: Bearer <aad-access-token>
```
- API Server ka OIDC Authenticator ye token Azure AD ke public keys se verify karta hai.
- API Server token se identity extract karta hai (AAD username, groups).
- RBAC rules check hote hain.
- Agar tumhe pods list karne ka permission hai → response return hota hai.

<br>

### Summary Flow Diagram
```
Azure CLI (az aks get-credentials)
       ↓
Azure Resource Manager (ARM)
       ↓
AKS Control Plane
       ↓
Returns kubeconfig (AAD/OIDC exec plugin)
       ↓
kubectl (exec plugin runs → gets fresh token)
       ↓
TLS handshake (server cert verify via CA)
       ↓
HTTP request with Bearer token
       ↓
K8s API Server (OIDC auth → RBAC check)
       ↓
Response to kubectl
```

<br>

### Key Points
- ```az aks get-credentials``` credentials generate nahi karta, bas kubeconfig fetch karta hai aks control plane se.
- Real authentication tab hota hai jab tum ```kubectl``` command chalate ho → tab Azure AD token liya jata hai.
- TLS handshake me sirf server verify hota hai, client cert nahi bhejta.
- Identity OIDC token me hoti hai, jo Azure AD sign karta hai.
- Azure DevOps pipeline ke case me tum manually Service Account token generate karke kubeconfig banaoge, kyunki CI/CD agent ke paas Azure CLI login nahi hota (ya tum AAD auth configure nahi karte).

<br>

**Note**: Uper detail main tumne ye dekha ki admin user jo azure provide karta hai Azure AD ke through us user se cluster access kaise hota hai.

Ab niche hum dekhenge ki agar humko custom user create karna hai aur us user ko limited access deni hai to vo kaise hoga.

<br>
<br>
<br>

## Kubernetes cluster ko Custom User ke thorugh kaise access karna hai.

Agar ek custom user ko kubernetes cluster par access dena hai, uske liye kuch methods hote hain, jaise:
- Azure AD (AAD) Based User.
- Kubernetes Native (Certificate-based Local User).
- Service Account + kubeconfig (Special Case).
- External Identity Provider (OIDC / SAML).

Uper given methods ke through hum ek user ko kubernetes par access de sakte hain.

<br>

### 1 - Azure AD (AAD) Based User:

Azure main ek service hoti hai **Azure Active Directory (AAD)** jisme hum user create karke user ko azure ka access provide karte hain.

Agar usi user ko jo AAD main create kiya hai usko AKS par access provide karna ho to hum Azure AD Based User method ko use karenge.

Suppose meri company ne mujhe azure par access provide kari, to company mera account Azure Active Directory main create karegi aur mujhe mere account ke credentials de degi jisse main azure main login kar saku. Agar usi Azure account main AKS created hai aur company ko mujhe AKS par access dena hai to company mujhe AKS par access dene ke liye Azure AD based method ko use karegi.

**Concept**:
- Tum user ka Azure AD account banaoge (ya agar pehle se hai to use use karoge).
- AKS ko Azure AD ke saath integrate karoge (AKS already support karta hai).
- RBAC ke saath user ko limited permission doge.

**Flow**:
- Azure Portal → Azure Active Directory → User create (```user@company.com```).
- AKS me Azure AD integration enable karte ho (usually default in new clusters).
- Agar enable nhi hai to cli se enable kar sakte hain.

Example:
```
az aks create \
  --resource-group MyResourceGroup \
  --name MyAKSCluster \
  --enable-aad \
  --aad-admin-group-object-ids <AAD-Group-Object-ID> \
  --enable-azure-rbac \
  --node-count 2 \
  --generate-ssh-keys
```
Explanation:
  - ```--enable-aad``` → AAD authentication enable karega.
  - ```--aad-admin-group-object-ids``` → AAD group jo cluster admin hoga.
  - ```--enable-azure-rbac``` → Azure RBAC for Kubernetes authorization enable karega.

- Kubernetes main RBAC Role / RoleBinding banao, jisse user authorize ho sake:
  - Subject = Azure AD user / group.
  - Role = pods & deployments read-only.
- User az login karega apne Azure AD account se.
- User az aks get-credentials karega aur cluster se connect hoga.

**Pros**:
- Centralized identity management (AAD).
- Easy revoke / password reset.
- Organization security policy follow hota hai.

**Cons**:
- Azure AD integration knowledge required.
- AAD ke bahar use nahi hota.

<br>
<br>

### Kubernetes Native (Certificate-based Local User)

Ye method **X.509 certificate** wala method hai.

<br>

**Background Concept: Kubernetes Native User (Certificate-based)**:

Kubernetes ke andar koi built-in "user create" command nahi hota. Matlab ```kubectl create user``` jaisa kuch nahi milta.

Reason: Kubernetes users cluster ke andar stored nahi hote, balki API server ke authentication mechanism ke through aate hain.

Types of users in Kubernetes:
- Service Accounts: Cluster ke andar apps/pods ke liye.
- Normal Users → Cluster ke bahar ke insaanon ke liye (admin, developer, tester).

Yaha hum Certificates-based local user method use kar rahe hain.

**Flow**:
- Hum ek private key aur certificate signing request (CSR) banayenge.
- CSR ko Kubernetes ke CertificateSigningRequest API ke through approve karenge.
- Kubernetes CA (cluster CA) us CSR ko sign karega → hume ek signed certificate milega.
- Is certificate ko hum apne ```kubectl``` config me use karke cluster ke andar connect karenge.
- RBAC rules lagayenge taaki us user ko sirf pods aur deployments read-only access mile.

<br>

**Example - (Lab Setup)**:
- Tumhare paas already:
  - AKS cluster bana hua hai (Azure CLI se ya Azure Portal se):
  - Tumhare paas kubectl ka admin access hai.
 
- Target:
  - User name: ```puneet```.
  - Access: Sirf get, list, watch on Pods and Deployments in entire cluster (ya optionally ek namespace).
 
**Step-1: Create Private Key and CSR for Puneet**:

Hum ek OpenSSL command se private key aur CSR banayenge.

Example:
```
# Step 1: Generate Puneet's private key
openssl genrsa -out puneet.key 2048

# Step 2: Create CSR config file
cat > puneet-csr.conf <<EOF
[ req ]
default_bits       = 2048
prompt             = no
default_md         = sha256
req_extensions     = req_ext
distinguished_name = dn

[ dn ]
CN = puneet
O = dev-team

[ req_ext ]
subjectAltName = @alt_names

[ alt_names ]
DNS.1 = puneet.dev.local
EOF

# Step 3: Generate CSR using private key and config
openssl req -new -key puneet.key -out puneet.csr -config puneet-csr.conf
```
Explanation:
- ```CN``` → Common Name (Kubernetes me username).
- ```O``` → Organization (Kubernetes me RBAC group ke liye useful).
- Ye ```puneet.csr``` hum Kubernetes ke paas bhejenge.

**Step-2: Create Kubernetes CSR Object**:

Ab hum CSR ko Kubernetes ke ```CertificateSigningRequest``` resource ke through kubernetes ko submit karenge.

Example:
```
# Encode CSR in base64
CSR_BASE64=$(cat puneet.csr | base64 | tr -d "\n")

# Create CSR YAML
cat > puneet-csr.yaml <<EOF
apiVersion: certificates.k8s.io/v1
kind: CertificateSigningRequest
metadata:
  name: puneet-csr
spec:
  request: ${CSR_BASE64}
  signerName: kubernetes.io/kube-apiserver-client
  usages:
  - client auth
EOF

# Apply CSR in cluster
kubectl apply -f puneet-csr.yaml
```
Explanation:
- ```signerName: kubernetes.io/kube-apiserver-client``` → ye batata hai ki ye client authentication ke liye hai (user access).
- ```usages```: client auth → certificate client ke authentication ke liye hai.

**Step-3: Approve the CSR**:

CSR ban gaya, ab cluster admin isko approve karega:

Example:
```
kubectl get csr
kubectl certificate approve puneet-csr
```

**Step-4: Extract the Signed Certificate**:

CSR approve hone ke baad cluster CA isko sign karega. Ab signed certificate download karte hain:

Example:
```
kubectl get csr puneet-csr -o jsonpath='{.status.certificate}' \
    | base64 --decode > puneet.crt
```

Ab tumhare paas:
- ```puneet.key``` → Private key.
- ```puneet.crt``` → Signed certificate.
- Ye dono mila ke tum Puneet ke kubectl config me daloge.

**Step-5: Configure kubeconfig for Puneet**:

Ab Puneet apne kubeconfig me apna cert/key add karega.

Example:
```
kubectl config set-credentials puneet \
  --client-certificate=puneet.crt \
  --client-key=puneet.key \
  --embed-certs=true

kubectl config set-context puneet-context \
  --cluster=$(kubectl config view --minify -o jsonpath='{.clusters[0].name}') \
  --namespace=default \
  --user=puneet
```

Puneet ab apne context me switch karega:

Example:
```
kubectl config use-context puneet-context
```

**Step-6: Create RBAC Role and RoleBinding**

Ab admin puneet ke liye sirf pods aur deployments read-only access denge.

Example:
```
# Create Role
cat > read-pod-deploy-role.yaml <<EOF
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: read-pod-deploy
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "watch"]
EOF

# Create RoleBinding
cat > read-pod-deploy-binding.yaml <<EOF
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: read-pod-deploy-binding
subjects:
- kind: User
  name: puneet
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: read-pod-deploy
  apiGroup: rbac.authorization.k8s.io
EOF

kubectl apply -f read-pod-deploy-role.yaml
kubectl apply -f read-pod-deploy-binding.yaml
```

**Note**:
- ```subjects.name```: Puneet ka CN (Common Name) match hona chahiye jo tumne CSR me diya tha.
- Humne ```ClusterRole``` use kiya kyunki humne poore cluster me read access dena hai, sirf ek namespace me nahi.

**Step-7:  Verification**:

Ab Puneet try karega:

Example:
```
# Allowed
kubectl get pods
kubectl get deployments

# Not Allowed
kubectl delete pod mypod
kubectl create deployment test --image=nginx
```

- Delete/create pe “forbidden” error aayega.

This is the complete Kubernetes Native (Certificate-based Local User).


