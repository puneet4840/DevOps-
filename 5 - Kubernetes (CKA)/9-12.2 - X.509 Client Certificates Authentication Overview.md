# X.509 Client Certificates Authentication Overview

Kubernetes ke Authentication aur Authorization process main jo request Api Server par jati hai usko authenticate karne ke liye alag-alag methods hote hain. Jaise tum kubernetes cluster ke admin ho aur cluster ko access karna chate ho to cluster ko access karne ke liye tumko koi method to use karna padega, to iske liye ye method hota hai.

X.509 client certificates are used to establish secure, authenticated connections between a client and a server.

**Example**:
```Suppose tumne azure main ek kubernetes cluster banaya hai, jab tum apne local system se cluster ko access karte ho to tumko ```kubectl``` client ki jarurat hoti hai, to tum ```kubectl``` tool apne system main install kar lete ho. Fir tum azure portal main kubernetes cluster service par jake connect option main jaate ho aur wha se ek cli command copy kar lete ho aur apne system ke command promt main paste kar dete ho, ye cli command ek ```kube-config``` file ko tumhare system main download kar deti hai, is ```kube-config``` file ke ander user ki information, cluster ki information aur access key ya secret hota hai jo azure ne cluster par access karne ke liye provide kiya hota hai.```

```Ab tum is cli command ko paste karke enter karte ho to tumko kubernetes clsuter ka access mil jata hai. To jab tumne ```kubectl``` ke through cluster par access karne ka try kiya to cluster main authenication aur authorization process hoti hai.```

```To ye ```kubectl``` client tumhari kubernetes command ko http form main convert karke kubernetes cluster ke api server par send karta hai. Fir api server us http request ko authenticate aur authorize karta hai.```

```Uper tumne dekha ki cluster par access karne ke liye tumne azure ke secret ya token ka use kiya. Lekin hum khud ka secret ya token create karke bhi cluster par access le sakte hain.```

Usi ke liye ye method hota hai **X.509 Client Certificates**.

<br>

### Basic Idea of X.509 Client Certificates
- X.509 ek international standard hai public key infrastructure (PKI) certificates ka.
- A PKI certificate is a digital credential issued by a certificate authority (CA) that authenticates users, devices, or applications.
- PKI is a digital document that verifies the identity of an entity (person, device, or application) and provides a public key for secure communication.
- Is method me tum public-private key pair generate karte ho, aur ek Certificate Authority (CA) us public key ko sign karke ek client certificate banata hai.
- Kubernetes API Server us certificate ko validate karke tumhari identity confirm karta hai.

<br>

### Kubernetes me X.509 Client Certificates Use Kahan Hota Hai?

- Cluster Administrators ke liye:
  - Admin access dene ke liye kubeconfig me certificate add hota hai.
 
- Kubelet → API Server Communication:
  - Har node apne kubelet ke liye ek client certificate use karta hai.
 
- Automation Scripts:
   - Direct API calls ke liye ```curl``` ya API client libraries.
 
<br>

### Authentication Flow 

**Step 1 – User ke paas ek Private Key hoti hai (Safe rakhi jati hai)**:

Is step main tum openssl tool ke through apne system main ek private kay generate karte ho.

Example:
```
openssl genrsa -out puneet.key 2048
```
Ye ```puneet.key``` tumhari private key hai — isse tumhare naam ka certificate banega.

- Private Key ka matlab kya hai?
  - Ye ek cryptographic key hoti hai jo sirf user ke paas hoti hai. Ye basically ek “secret” hai jo asymmetric encryption ke principle pe kaam karti hai.
    
- Asymmetric Encryption ka funda:
  - 2 keys hoti hain → Private Key (secret) & Public Key (shareable).
  - Private key se encrypt kiya data sirf public key se decrypt hota hai, aur vice-versa.
  - Authentication me, private key kaam aata hai signature banane me — jo prove karta hai ki tum hi tum ho.
 
- Security ka golden rule:
  - Private key kabhi share nahi hoti, na email, na GitHub, na Slack — sirf tumhare system ya secure vault me stored rehti hai.

- Kubernetes context me:
  - Jab tum X.509 client certificate authentication karte ho, tumhari private key tumhara proof of identity hai. Agar ye leak ho jaye → koi bhi tum ban sakta hai cluster me.
 
<br>

**Step 2 – Private key ka public part ek CSR (Certificate Signing Request) me package kiya jata hai**:

Is step main tum apni private key se ek CSR (Certificate Sigining Request) banate ho, iska matlab hai ki tum openssl tool ko private key dete ho, fir openssl tool tumhari private key se public key drive karke public key se ek Certificate Sigining Request create karta hai. Is certificate signing request main public key, digital certificate air info hota hai. openssl public key ko digitally sign karega jisse ek certificate generate ho jata hai aur vo certificate ko use karke CA verify kar payega ki tum uske owner ho.

- Private key se hum ek public key extract karte hain:
```
openssl rsa -in puneet.key -pubout -out puneet.pub
```

CSR kya hota hai?
- CSR ek structured file hoti hai jisme public key + subject info + digital signature hota hai.
- Certificate Signing Request ek document hota hai jisme:
  - Tumhara public key.
  - Tumhara identity info (CN = Common Name, O = Organization, etc.).
  - Tumhara signature (jo tum private key se karte ho to prove authenticity) hota hai.

Kyun CSR banate hain?
- Ye basically CA ko request hoti hai ki:
  - "Mere is public key ko verify karke ek signed certificate bana do jo sab trust karein."

Kubernetes me important:
- CSR ka CN field = tumhara username.
- CSR ka O field = tumhara group name.
- Ye baad me RBAC rules me use hota hai.

Example Command – CSR banana:
```
openssl req -new -key puneet.key -out puneet.csr -subj "/CN=puneet/O=dev-team"
```

<br>

**Step 3 – CSR ko Kubernetes CA sign karta hai → X.509 client certificate ban jata hai**:

Is step main CSR (Certificate Signing Request) ko kubernetes ke Certificate Authority ko bhejte hain jo kubernetes ka default certificate authority hota hai. openssl tool ke through isko kubernetes ke CA ko bhejte hain, fir CA is CSR se ek certificate bana deta hai ```puneet.crt```. 

- CA (Certificate Authority) ka role:
  - CA ek trusted entity hoti hai jiska apna private key hota hai. Kubernetes cluster ke paas apna CA hota hai (ca.crt & ca.key).
 
- Signing ka matlab:
  - CA tumhare CSR me diya hua public key leke uske upar apna signature lagata hai → Ye proof hai ki "Haan, maine is public key wale insaan ko verify kiya hai."
 
- Kubernetes ke CA se sign kaise hota hai:

Example:
```
openssl x509 -req -in puneet.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out puneet.crt -days 365
```

- Resule:
  - Tumhare paas ab ek X.509 client certificate (```puneet.crt```) hai jo CA signed hai → API server is CA ko trust karta hai.
 
<br>

**Step 4 – Client jab API request bhejta hai**:

Ab tum kubectl ya koi client tool use karke kubernetes ke Api Server pe API call karoge, jisme tum ```get pods``` ya kuch bhi kubernetes ki command likhte ho:
```
kubectl --server=https://api.example.com:6443 \
        --client-certificate=puneet.crt \
        --client-key=puneet.key \
        get pods
```

- Is request me tum apna client certificate attach karte ho jo CA signed hai.

<br>

**Step 6 – API Server apne trusted CA ke against certificate verify karta hai**:
- API server ke paas apna ```--client-ca-file=/etc/kubernetes/pki/ca.crt``` configured hota hai.
- Ye CA file ka use karke wo tumhare client certificate ka signature verify karta hai:
  - Kya certificate is CA se signed hai?
  - Kya certificate expired to nahi?
  - Kya certificate revoked to nahi?

<br>

**Step 7 – Agar signature match ho → identity confirm hoti hai**:
- Signature verify hone ka matlab hai:
  - Tumhare paas jis private key ka public key certificate me hai, tum wahi user ho.
  - Tumhare certificate me jo CN aur O fields hain, wo tumhara "username" aur "groups" ban jate hain.
 
<br>

**Step 8 – Identity confirm hone ke baad Authorization stage pe jaata hai**:
- Ab Kubernetes RBAC (Role-Based Access Control) check karega:
  - Kya CN=puneet user ko pods list karne ka right hai?
  - Agar haan → request allow
  - Agar nahi → request deny
 
<br>
<br>


## Practical Example

Chalo ek example lete hain jisme hum "puneet" naam ka ek user create karenge jo Kubernetes API ko certificate ke through authenticate karega.

**Step 1 — Private Key Generate Karna**:

Example:
```
openssl genrsa -out puneet.key 2048
```
- Ye tumhara private key hai.
- Isse safe rakho, kisi ko mat do.
- Iska size 2048 bits rakha — secure hai.

<br>

**Step 2 — Certificate Signing Request (CSR) Generate Karna**:

Example:
```
openssl req -new -key puneet.key -out puneet.csr -subj "/CN=puneet/O=dev-team"
```
- ```/CN=puneet``` → Common Name → Ye username hoga jo Kubernetes me appear hoga.
- ```/O=dev-team``` → Organization → Ye Kubernetes RBAC me group ke roop me use hota hai.
- CSR ke andar tumhara public key hota hai.

<br>

**Step 3 — CSR ko CA se Sign Karwana**:

Kubernetes apna Cluster CA use karta hai jo ```/etc/kubernetes/pki/ca.crt``` & ```ca.key``` me hota hai.

Example:
```
sudo openssl x509 -req -in puneet.csr \
  -CA /etc/kubernetes/pki/ca.crt \
  -CAkey /etc/kubernetes/pki/ca.key \
  -CAcreateserial \
  -out puneet.crt -days 365
```
- Ye tumhara client certificate ban gaya — valid for 1 year.
- Isme CA ka digital signature hota hai.

<br>

**Step 4 — Kubeconfig File Create Karna**:

Ab ```kubectl``` ke liye ek alag kubeconfig create karte hain jo ye certificate use kare.

Example:
```
kubectl config set-credentials puneet \
  --client-certificate=puneet.crt \
  --client-key=puneet.key \
  --embed-certs=true
```

Cluster ka context add karo:
```
kubectl config set-context puneet-context \
  --cluster=kubernetes \
  --namespace=default \
  --user=puneet
```

Context switch karo:
```
kubectl config use-context puneet-context
```

<br>

**Step 5 — RBAC Permissions Dena**:

Authentication ke baad Authorization zaroori hai, warna 403 Forbidden milega.

Example Role:
```
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: pod-reader
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
```

Example Role Binding:
```
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: read-pods-binding
  namespace: default
subjects:
- kind: User
  name: puneet  # CN in certificate
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```

Apply:
```
kubectl apply -f role.yaml
kubectl apply -f rolebinding.yaml
```

<br>

**Step 6 — Test Authentication**:
```
kubectl get pods
```

- Agar sab sahi hai → Tum pods list kar paoge.
- Agar certificate invalid hai → Unable to connect to the server: x509: certificate signed by unknown authority.
- Agar AuthZ fail hai → Error from server (Forbidden).

<br>
<br>

### Common Mistakes
- CN (Common Name) ka RBAC me match na hona.
- Kubeconfig me galat certificate/key path.
- CA ke trust store me CA certificate add na karna.
- Expired certificates ka use.

<br>

### Advantages & Limitations

**Advantages**:
- Extremely secure (TLS + PKI).
- Offline authentication — no need for external auth provider.
- Works well for kubelet, admin, automation.

**Limitations**:
- Manual certificate rotation required.
- Not scalable for thousands of human users (OIDC better there).
- CSR signing ke liye CA access chahiye hota hai.
