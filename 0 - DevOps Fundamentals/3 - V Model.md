# V Model (Validation and Verification Model)

In this V model testing is planned in parallel with each phase. Each phase must be completed before moving to the next phase and it follow sequestial design process same as waterfall model.

It is called V-Model because it forms a V shape as software development phases in left side and testing phases in the right side.

In simple words, for every software development activity, there is directly associated testing activity.

```इस phase मैं हर software development phase के साथ testing activity होती है```

<br>

### Why was V-Model introduced?

```Waterfall Model. Saal tha 1970. Tum ek naye project mein ho, aur tumhare manager bolte hain ki ab hum ek formal process follow karenge. Sabse pehle hum requirements likhenge, fir unka design banayenge, fir code likhenge, fir testing, aur phir deploy karenge. Tumhein laga, "Waah! Kitni planning hai!" Har cheez ek sequence mein ho rahi thi, jaise paani waterfall se girta hai—upar se neeche. Sab kuch document hota tha. Client bhi khush tha, kyunki usse lagta tha ki project professional tarike se chal raha hai.```

```Lekin phir kuch mahine baad client ne kaha, “Humein ek aur feature chahiye.” Tumhara poora structure hil gaya. Tumhein dobara planning se leke deployment tak sab kuch karna pada. Tum realize karte ho ki yeh model stable hai, lekin flexible nahi hai. Software banate waqt agar beech mein koi change aaye, toh yeh model bekaar ho jata hai.```

```Isi frustration ke beech aata hai V-Model. Tum sochte ho, “Agar development ke har step ke saath testing bhi karun, toh issues end mein nahi aayenge.” V-Model ke andar tum pehle requirement lete ho, aur saath hi acceptance test plan banate ho. Design ke saath system test plan. Coding ke saath unit tests. Tumhara code kaafi achha chalne lagta hai. Lekin ek problem ab bhi hai—client agar beech mein kuch badalna chahe, toh tum phir se poora flow mein jaate ho. Time zyada lagta hai, aur phir se wahi rigidness tumhe feel hoti hai.```

<br>

Before V-Model, we mostly used the Waterfall model, which had a major drawback:
- Testing came only after development, which led to late discovery of bugs.

So, the industry needed a model where:
- Testing could be started early (before code is written).
- Defects could be caught as soon as possible

That’s where V-Model came in — as a refined and more test-driven evolution of Waterfall.

<br>

### V-Model Structure (Phase-by-Phase)

<img src="https://drive.google.com/uc?export=view&id=1x74SD6sgJ6_V1DFSoQerEv0eGh8VZ2fs" height=350 weight=350>

<img src="https://drive.google.com/uc?export=view&id=1ccXQObGYrLmV-dgUqB4vHOWs9xet5Sjb" height=150 weight=150>
